
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Nov 23 19:31:03 CST 2025
//----------------------------------------------------

package act2;

import java_cup.runtime.*;
import java.io.*;
import act2.ParserHelper;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Nov 23 19:31:03 CST 2025
  */
public class Sintactico extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Sintactico() {super();}

  /** Constructor which sets the default scanner. */
  public Sintactico(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Sintactico(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\176\000\002\002\004\000\002\002\003\000\002\002" +
    "\002\000\002\003\004\000\002\003\003\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\004\004\000" +
    "\002\004\004\000\002\055\002\000\002\005\011\000\002" +
    "\056\002\000\002\005\010\000\002\006\003\000\002\006" +
    "\002\000\002\007\004\000\002\007\003\000\002\010\003" +
    "\000\002\010\003\000\002\057\002\000\002\011\013\000" +
    "\002\060\002\000\002\011\013\000\002\012\003\000\002" +
    "\012\002\000\002\013\005\000\002\013\003\000\002\014" +
    "\004\000\002\053\002\000\002\053\003\000\002\054\003" +
    "\000\002\054\005\000\002\015\003\000\002\015\003\000" +
    "\002\015\003\000\002\015\003\000\002\015\003\000\002" +
    "\016\005\000\002\017\003\000\002\020\005\000\002\020" +
    "\003\000\002\021\003\000\002\021\005\000\002\023\003" +
    "\000\002\023\002\000\002\024\004\000\002\024\003\000" +
    "\002\061\002\000\002\022\006\000\002\022\003\000\002" +
    "\022\003\000\002\022\003\000\002\022\003\000\002\022" +
    "\003\000\002\022\003\000\002\022\003\000\002\022\003" +
    "\000\002\022\003\000\002\022\004\000\002\022\004\000" +
    "\002\044\002\000\002\045\002\000\002\062\002\000\002" +
    "\031\013\000\002\063\002\000\002\025\011\000\002\064" +
    "\002\000\002\065\002\000\002\025\015\000\002\066\002" +
    "\000\002\026\012\000\002\067\002\000\002\070\002\000" +
    "\002\071\002\000\002\027\022\000\002\041\004\000\002" +
    "\041\003\000\002\041\002\000\002\032\003\000\002\032" +
    "\002\000\002\042\003\000\002\042\002\000\002\043\005" +
    "\000\002\037\004\000\002\072\002\000\002\073\002\000" +
    "\002\033\017\000\002\034\004\000\002\034\003\000\002" +
    "\034\004\000\002\034\003\000\002\074\002\000\002\035" +
    "\007\000\002\075\002\000\002\036\006\000\002\030\005" +
    "\000\002\030\004\000\002\040\004\000\002\052\003\000" +
    "\002\052\003\000\002\052\003\000\002\052\003\000\002" +
    "\052\003\000\002\052\006\000\002\052\003\000\002\052" +
    "\005\000\002\052\005\000\002\052\005\000\002\052\005" +
    "\000\002\052\005\000\002\052\005\000\002\052\005\000" +
    "\002\052\005\000\002\052\004\000\002\052\005\000\002" +
    "\052\005\000\002\052\005\000\002\052\005\000\002\052" +
    "\005\000\002\052\005\000\002\052\003\000\002\052\007" +
    "\000\002\052\005\000\002\052\010\000\002\052\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\350\000\026\002\uffff\003\015\004\022\011\011\031" +
    "\006\032\020\035\007\036\021\037\012\114\016\001\002" +
    "\000\004\002\352\001\002\000\026\002\ufffa\003\ufffa\004" +
    "\ufffa\011\ufffa\031\ufffa\032\ufffa\035\ufffa\036\ufffa\037\ufffa" +
    "\114\ufffa\001\002\000\004\076\uffe0\001\002\000\004\076" +
    "\uffdc\001\002\000\026\002\ufffb\003\ufffb\004\ufffb\011\ufffb" +
    "\031\ufffb\032\ufffb\035\ufffb\036\ufffb\037\ufffb\114\ufffb\001" +
    "\002\000\004\076\342\001\002\000\004\076\uffdd\001\002" +
    "\000\026\002\ufffd\003\ufffd\004\ufffd\011\ufffd\031\ufffd\032" +
    "\ufffd\035\ufffd\036\ufffd\037\ufffd\114\ufffd\001\002\000\026" +
    "\002\000\003\015\004\022\011\011\031\006\032\020\035" +
    "\007\036\021\037\012\114\016\001\002\000\004\072\340" +
    "\001\002\000\004\072\337\001\002\000\004\076\042\001" +
    "\002\000\004\076\uffdf\001\002\000\004\076\uffde\001\002" +
    "\000\004\076\024\001\002\000\026\002\ufffc\003\ufffc\004" +
    "\ufffc\011\ufffc\031\ufffc\032\ufffc\035\ufffc\036\ufffc\037\ufffc" +
    "\114\ufffc\001\002\000\004\065\025\001\002\000\020\011" +
    "\ufff7\031\ufff7\032\ufff7\035\ufff7\036\ufff7\037\ufff7\066\ufff7" +
    "\001\002\000\020\011\011\031\006\032\020\035\007\036" +
    "\021\037\012\066\ufff2\001\002\000\020\011\011\031\006" +
    "\032\020\035\007\036\021\037\012\066\ufff2\001\002\000" +
    "\020\011\uffee\031\uffee\032\uffee\035\uffee\036\uffee\037\uffee" +
    "\066\uffee\001\002\000\020\011\011\031\006\032\020\035" +
    "\007\036\021\037\012\066\ufff3\001\002\000\020\011\uffef" +
    "\031\uffef\032\uffef\035\uffef\036\uffef\037\uffef\066\uffef\001" +
    "\002\000\004\066\035\001\002\000\020\011\ufff0\031\ufff0" +
    "\032\ufff0\035\ufff0\036\ufff0\037\ufff0\066\ufff0\001\002\000" +
    "\004\072\036\001\002\000\026\002\ufff6\003\ufff6\004\ufff6" +
    "\011\ufff6\031\ufff6\032\ufff6\035\ufff6\036\ufff6\037\ufff6\114" +
    "\ufff6\001\002\000\020\011\ufff1\031\ufff1\032\ufff1\035\ufff1" +
    "\036\ufff1\037\ufff1\066\ufff1\001\002\000\004\066\041\001" +
    "\002\000\026\002\ufff4\003\ufff4\004\ufff4\011\ufff4\031\ufff4" +
    "\032\ufff4\035\ufff4\036\ufff4\037\ufff4\114\ufff4\001\002\000" +
    "\012\051\052\063\uffed\071\uffd7\072\uffd7\001\002\000\006" +
    "\071\047\072\uffda\001\002\000\006\071\uffd8\072\uffd8\001" +
    "\002\000\004\072\046\001\002\000\102\002\uffdb\003\uffdb" +
    "\004\uffdb\011\uffdb\012\uffdb\013\uffdb\014\uffdb\015\uffdb\016" +
    "\uffdb\017\uffdb\020\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb" +
    "\025\uffdb\031\uffdb\032\uffdb\035\uffdb\036\uffdb\037\uffdb\041" +
    "\uffdb\060\uffdb\063\uffdb\065\uffdb\066\uffdb\076\uffdb\077\uffdb" +
    "\100\uffdb\101\uffdb\102\uffdb\114\uffdb\001\002\000\004\076" +
    "\050\001\002\000\010\051\052\071\uffd7\072\uffd7\001\002" +
    "\000\006\071\uffd9\072\uffd9\001\002\000\030\003\063\025" +
    "\055\041\056\060\065\063\066\076\062\077\057\100\053" +
    "\101\060\102\054\114\064\001\002\000\046\044\uff9d\045" +
    "\uff9d\046\uff9d\047\uff9d\050\uff9d\052\uff9d\053\uff9d\054\uff9d" +
    "\055\uff9d\056\uff9d\057\uff9d\061\uff9d\062\uff9d\064\uff9d\071" +
    "\uff9d\072\uff9d\073\uff9d\074\uff9d\001\002\000\046\044\uff9b" +
    "\045\uff9b\046\uff9b\047\uff9b\050\uff9b\052\uff9b\053\uff9b\054" +
    "\uff9b\055\uff9b\056\uff9b\057\uff9b\061\uff9b\062\uff9b\064\uff9b" +
    "\071\uff9b\072\uff9b\073\uff9b\074\uff9b\001\002\000\004\076" +
    "\140\001\002\000\046\044\uff9a\045\uff9a\046\uff9a\047\uff9a" +
    "\050\uff9a\052\uff9a\053\uff9a\054\uff9a\055\uff9a\056\uff9a\057" +
    "\uff9a\061\uff9a\062\uff9a\064\uff9a\071\uff9a\072\uff9a\073\uff9a" +
    "\074\uff9a\001\002\000\046\044\uff9e\045\uff9e\046\uff9e\047" +
    "\uff9e\050\uff9e\052\uff9e\053\uff9e\054\uff9e\055\uff9e\056\uff9e" +
    "\057\uff9e\061\uff9e\062\uff9e\064\uff9e\071\uff9e\072\uff9e\073" +
    "\uff9e\074\uff9e\001\002\000\046\044\uff9c\045\uff9c\046\uff9c" +
    "\047\uff9c\050\uff9c\052\uff9c\053\uff9c\054\uff9c\055\uff9c\056" +
    "\uff9c\057\uff9c\061\uff9c\062\uff9c\064\uff9c\071\uff9c\072\uff9c" +
    "\073\uff9c\074\uff9c\001\002\000\042\044\072\045\104\046" +
    "\076\047\102\050\101\052\100\053\075\054\073\055\077" +
    "\056\106\057\074\061\070\062\105\071\uffd6\072\uffd6\074" +
    "\071\001\002\000\050\044\uff98\045\uff98\046\uff98\047\uff98" +
    "\050\uff98\052\uff98\053\uff98\054\uff98\055\uff98\056\uff98\057" +
    "\uff98\061\uff98\062\uff98\063\135\064\uff98\071\uff98\072\uff98" +
    "\073\uff98\074\uff98\001\002\000\046\044\uff88\045\uff88\046" +
    "\uff88\047\uff88\050\uff88\052\uff88\053\uff88\054\uff88\055\uff88" +
    "\056\uff88\057\uff88\061\uff88\062\uff88\064\uff88\071\uff88\072" +
    "\uff88\073\uff88\074\uff88\001\002\000\046\044\uff84\045\uff84" +
    "\046\uff84\047\uff84\050\uff84\052\uff84\053\uff84\054\uff84\055" +
    "\uff84\056\uff84\057\uff84\061\uff84\062\uff84\064\uff84\071\uff84" +
    "\072\uff84\073\uff84\074\uff84\001\002\000\030\003\063\025" +
    "\055\041\056\060\065\063\066\076\062\077\057\100\053" +
    "\101\060\102\054\114\064\001\002\000\030\003\063\025" +
    "\055\041\056\060\065\063\066\076\062\077\057\100\053" +
    "\101\060\102\054\114\064\001\002\000\040\044\072\045" +
    "\104\046\076\047\102\050\101\052\100\053\075\054\073" +
    "\055\077\056\106\057\074\061\070\062\105\064\103\074" +
    "\071\001\002\000\030\003\063\025\055\041\056\060\065" +
    "\063\066\076\062\077\057\100\053\101\060\102\054\114" +
    "\064\001\002\000\004\076\123\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\046\044\uff97" +
    "\045\uff97\046\uff97\047\uff97\050\uff97\052\uff97\053\uff97\054" +
    "\uff97\055\uff97\056\uff97\057\uff97\061\uff97\062\uff97\064\uff97" +
    "\071\uff97\072\uff97\073\uff97\074\uff97\001\002\000\030\003" +
    "\063\025\055\041\056\060\065\063\066\076\062\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\030\003" +
    "\063\025\055\041\056\060\065\063\066\076\062\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\030\003" +
    "\063\025\055\041\056\060\065\063\066\076\062\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\046\044" +
    "\072\045\104\046\076\047\102\050\101\052\uff8a\053\uff8a" +
    "\054\uff8a\055\uff8a\056\uff8a\057\uff8a\061\uff8a\062\uff8a\064" +
    "\uff8a\071\uff8a\072\uff8a\073\uff8a\074\uff8a\001\002\000\046" +
    "\044\072\045\104\046\076\047\102\050\101\052\100\053" +
    "\075\054\073\055\077\056\106\057\074\061\070\062\uff90" +
    "\064\uff90\071\uff90\072\uff90\073\uff90\074\uff90\001\002\000" +
    "\046\044\uff95\045\uff95\046\076\047\102\050\101\052\uff95" +
    "\053\uff95\054\uff95\055\uff95\056\uff95\057\uff95\061\uff95\062" +
    "\uff95\064\uff95\071\uff95\072\uff95\073\uff95\074\uff95\001\002" +
    "\000\046\044\uff93\045\uff93\046\uff93\047\uff93\050\uff93\052" +
    "\uff93\053\uff93\054\uff93\055\uff93\056\uff93\057\uff93\061\uff93" +
    "\062\uff93\064\uff93\071\uff93\072\uff93\073\uff93\074\uff93\001" +
    "\002\000\046\044\uff92\045\uff92\046\uff92\047\uff92\050\uff92" +
    "\052\uff92\053\uff92\054\uff92\055\uff92\056\uff92\057\uff92\061" +
    "\uff92\062\uff92\064\uff92\071\uff92\072\uff92\073\uff92\074\uff92" +
    "\001\002\000\046\044\072\045\104\046\076\047\102\050" +
    "\101\052\uff8e\053\uff8e\054\073\055\077\056\106\057\074" +
    "\061\uff8e\062\uff8e\064\uff8e\071\uff8e\072\uff8e\073\uff8e\074" +
    "\uff8e\001\002\000\046\044\072\045\104\046\076\047\102" +
    "\050\101\052\uff8b\053\uff8b\054\uff8b\055\uff8b\056\uff8b\057" +
    "\uff8b\061\uff8b\062\uff8b\064\uff8b\071\uff8b\072\uff8b\073\uff8b" +
    "\074\uff8b\001\002\000\046\044\uff94\045\uff94\046\uff94\047" +
    "\uff94\050\uff94\052\uff94\053\uff94\054\uff94\055\uff94\056\uff94" +
    "\057\uff94\061\uff94\062\uff94\064\uff94\071\uff94\072\uff94\073" +
    "\uff94\074\uff94\001\002\000\046\044\072\045\104\046\076" +
    "\047\102\050\101\052\uff8d\053\uff8d\054\073\055\077\056" +
    "\106\057\074\061\uff8d\062\uff8d\064\uff8d\071\uff8d\072\uff8d" +
    "\073\uff8d\074\uff8d\001\002\000\046\044\072\045\104\046" +
    "\076\047\102\050\101\052\uff89\053\uff89\054\uff89\055\uff89" +
    "\056\uff89\057\uff89\061\uff89\062\uff89\064\uff89\071\uff89\072" +
    "\uff89\073\uff89\074\uff89\001\002\000\046\044\072\045\104" +
    "\046\076\047\102\050\101\052\uff8c\053\uff8c\054\uff8c\055" +
    "\uff8c\056\uff8c\057\uff8c\061\uff8c\062\uff8c\064\uff8c\071\uff8c" +
    "\072\uff8c\073\uff8c\074\uff8c\001\002\000\046\044\uff96\045" +
    "\uff96\046\076\047\102\050\101\052\uff96\053\uff96\054\uff96" +
    "\055\uff96\056\uff96\057\uff96\061\uff96\062\uff96\064\uff96\071" +
    "\uff96\072\uff96\073\uff96\074\uff96\001\002\000\050\044\uff86" +
    "\045\uff86\046\uff86\047\uff86\050\uff86\052\uff86\053\uff86\054" +
    "\uff86\055\uff86\056\uff86\057\uff86\061\uff86\062\uff86\063\124" +
    "\064\uff86\071\uff86\072\uff86\073\uff86\074\uff86\001\002\000" +
    "\032\003\063\025\055\041\056\060\065\063\066\064\uffe4" +
    "\076\062\077\057\100\053\101\060\102\054\114\064\001" +
    "\002\000\006\064\uffe3\071\131\001\002\000\042\044\072" +
    "\045\104\046\076\047\102\050\101\052\100\053\075\054" +
    "\073\055\077\056\106\057\074\061\070\062\105\064\uffe2" +
    "\071\uffe2\074\071\001\002\000\004\064\130\001\002\000" +
    "\046\044\uff85\045\uff85\046\uff85\047\uff85\050\uff85\052\uff85" +
    "\053\uff85\054\uff85\055\uff85\056\uff85\057\uff85\061\uff85\062" +
    "\uff85\064\uff85\071\uff85\072\uff85\073\uff85\074\uff85\001\002" +
    "\000\030\003\063\025\055\041\056\060\065\063\066\076" +
    "\062\077\057\100\053\101\060\102\054\114\064\001\002" +
    "\000\042\044\072\045\104\046\076\047\102\050\101\052" +
    "\100\053\075\054\073\055\077\056\106\057\074\061\070" +
    "\062\105\064\uffe1\071\uffe1\074\071\001\002\000\046\044" +
    "\072\045\104\046\076\047\102\050\101\052\100\053\075" +
    "\054\073\055\077\056\106\057\074\061\uff91\062\uff91\064" +
    "\uff91\071\uff91\072\uff91\073\uff91\074\uff91\001\002\000\046" +
    "\044\uff8f\045\uff8f\046\uff8f\047\uff8f\050\uff8f\052\uff8f\053" +
    "\uff8f\054\uff8f\055\uff8f\056\uff8f\057\uff8f\061\uff8f\062\uff8f" +
    "\064\uff8f\071\uff8f\072\uff8f\073\uff8f\074\uff8f\001\002\000" +
    "\032\003\063\025\055\041\056\060\065\063\066\064\uffe4" +
    "\076\062\077\057\100\053\101\060\102\054\114\064\001" +
    "\002\000\004\064\137\001\002\000\046\044\uff99\045\uff99" +
    "\046\uff99\047\uff99\050\uff99\052\uff99\053\uff99\054\uff99\055" +
    "\uff99\056\uff99\057\uff99\061\uff99\062\uff99\064\uff99\071\uff99" +
    "\072\uff99\073\uff99\074\uff99\001\002\000\004\063\141\001" +
    "\002\000\032\003\063\025\055\041\056\060\065\063\066" +
    "\064\uffe4\076\062\077\057\100\053\101\060\102\054\114" +
    "\064\001\002\000\004\064\143\001\002\000\046\044\uff87" +
    "\045\uff87\046\uff87\047\uff87\050\uff87\052\uff87\053\uff87\054" +
    "\uff87\055\uff87\056\uff87\057\uff87\061\uff87\062\uff87\064\uff87" +
    "\071\uff87\072\uff87\073\uff87\074\uff87\001\002\000\004\063" +
    "\145\001\002\000\016\031\006\032\020\035\007\036\021" +
    "\037\012\064\uffe8\001\002\000\006\064\uffe6\071\uffe6\001" +
    "\002\000\004\064\155\001\002\000\004\076\154\001\002" +
    "\000\006\064\uffe9\071\152\001\002\000\014\031\006\032" +
    "\020\035\007\036\021\037\012\001\002\000\006\064\uffe7" +
    "\071\uffe7\001\002\000\006\064\uffe5\071\uffe5\001\002\000" +
    "\004\065\156\001\002\000\066\003\063\012\170\014\203" +
    "\015\162\016\207\017\176\022\175\023\161\024\173\025" +
    "\055\031\006\032\020\035\007\036\021\037\012\041\056" +
    "\060\065\063\066\065\200\066\uffd4\076\172\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\004\076\050" +
    "\001\002\000\074\003\uffcc\012\uffcc\013\uffcc\014\uffcc\015" +
    "\uffcc\016\uffcc\017\uffcc\020\uffcc\021\uffcc\022\uffcc\023\uffcc" +
    "\024\uffcc\025\uffcc\031\uffcc\032\uffcc\035\uffcc\036\uffcc\037" +
    "\uffcc\041\uffcc\060\uffcc\063\uffcc\065\uffcc\066\uffcc\076\uffcc" +
    "\077\uffcc\100\uffcc\101\uffcc\102\uffcc\114\uffcc\001\002\000" +
    "\004\072\336\001\002\000\004\063\311\001\002\000\074" +
    "\003\uffca\012\uffca\013\uffca\014\uffca\015\uffca\016\uffca\017" +
    "\uffca\020\uffca\021\uffca\022\uffca\023\uffca\024\uffca\025\uffca" +
    "\031\uffca\032\uffca\035\uffca\036\uffca\037\uffca\041\uffca\060" +
    "\uffca\063\uffca\065\uffca\066\uffca\076\uffca\077\uffca\100\uffca" +
    "\101\uffca\102\uffca\114\uffca\001\002\000\074\003\uffc8\012" +
    "\uffc8\013\uffc8\014\uffc8\015\uffc8\016\uffc8\017\uffc8\020\uffc8" +
    "\021\uffc8\022\uffc8\023\uffc8\024\uffc8\025\uffc8\031\uffc8\032" +
    "\uffc8\035\uffc8\036\uffc8\037\uffc8\041\uffc8\060\uffc8\063\uffc8" +
    "\065\uffc8\066\uffc8\076\uffc8\077\uffc8\100\uffc8\101\uffc8\102" +
    "\uffc8\114\uffc8\001\002\000\074\003\uffcf\012\uffcf\013\uffcf" +
    "\014\uffcf\015\uffcf\016\uffcf\017\uffcf\020\uffcf\021\uffcf\022" +
    "\uffcf\023\uffcf\024\uffcf\025\uffcf\031\uffcf\032\uffcf\035\uffcf" +
    "\036\uffcf\037\uffcf\041\uffcf\060\uffcf\063\uffcf\065\uffcf\066" +
    "\uffcf\076\uffcf\077\uffcf\100\uffcf\101\uffcf\102\uffcf\114\uffcf" +
    "\001\002\000\072\003\063\012\170\014\203\015\162\016" +
    "\207\017\176\020\uffd5\021\uffd5\022\175\023\161\024\173" +
    "\025\055\031\006\032\020\035\007\036\021\037\012\041" +
    "\056\060\065\063\066\065\200\066\uffd5\076\172\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\074\003" +
    "\uffcb\012\uffcb\013\uffcb\014\uffcb\015\uffcb\016\uffcb\017\uffcb" +
    "\020\uffcb\021\uffcb\022\uffcb\023\uffcb\024\uffcb\025\uffcb\031" +
    "\uffcb\032\uffcb\035\uffcb\036\uffcb\037\uffcb\041\uffcb\060\uffcb" +
    "\063\uffcb\065\uffcb\066\uffcb\076\uffcb\077\uffcb\100\uffcb\101" +
    "\uffcb\102\uffcb\114\uffcb\001\002\000\004\063\274\001\002" +
    "\000\074\003\uffcd\012\uffcd\013\uffcd\014\uffcd\015\uffcd\016" +
    "\uffcd\017\uffcd\020\uffcd\021\uffcd\022\uffcd\023\uffcd\024\uffcd" +
    "\025\uffcd\031\uffcd\032\uffcd\035\uffcd\036\uffcd\037\uffcd\041" +
    "\uffcd\060\uffcd\063\uffcd\065\uffcd\066\uffcd\076\uffcd\077\uffcd" +
    "\100\uffcd\101\uffcd\102\uffcd\114\uffcd\001\002\000\044\044" +
    "\uff98\045\uff98\046\uff98\047\uff98\050\uff98\051\272\052\uff98" +
    "\053\uff98\054\uff98\055\uff98\056\uff98\057\uff98\061\uff98\062" +
    "\uff98\063\135\072\uff98\074\uff98\001\002\000\032\003\063" +
    "\025\055\041\056\060\065\063\066\072\270\076\062\077" +
    "\057\100\053\101\060\102\054\114\064\001\002\000\040" +
    "\044\072\045\104\046\076\047\102\050\101\052\100\053" +
    "\075\054\073\055\077\056\106\057\074\061\070\062\105" +
    "\072\266\074\071\001\002\000\004\072\265\001\002\000" +
    "\004\063\234\001\002\000\004\066\233\001\002\000\066" +
    "\003\uffd1\012\uffd1\014\uffd1\015\uffd1\016\uffd1\017\uffd1\022" +
    "\uffd1\023\uffd1\024\uffd1\025\uffd1\031\uffd1\032\uffd1\035\uffd1" +
    "\036\uffd1\037\uffd1\041\uffd1\060\uffd1\063\uffd1\065\uffd1\066" +
    "\uffd1\076\uffd1\077\uffd1\100\uffd1\101\uffd1\102\uffd1\114\uffd1" +
    "\001\002\000\074\003\uffc7\012\uffc7\013\uffc7\014\uffc7\015" +
    "\uffc7\016\uffc7\017\uffc7\020\uffc7\021\uffc7\022\uffc7\023\uffc7" +
    "\024\uffc7\025\uffc7\031\uffc7\032\uffc7\035\uffc7\036\uffc7\037" +
    "\uffc7\041\uffc7\060\uffc7\063\uffc7\065\uffc7\066\uffc7\076\uffc7" +
    "\077\uffc7\100\uffc7\101\uffc7\102\uffc7\114\uffc7\001\002\000" +
    "\004\072\227\001\002\000\004\063\uffc4\001\002\000\072" +
    "\003\uffd2\012\uffd2\014\uffd2\015\uffd2\016\uffd2\017\uffd2\020" +
    "\uffd2\021\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\031\uffd2" +
    "\032\uffd2\035\uffd2\036\uffd2\037\uffd2\041\uffd2\060\uffd2\063" +
    "\uffd2\065\uffd2\066\uffd2\076\uffd2\077\uffd2\100\uffd2\101\uffd2" +
    "\102\uffd2\114\uffd2\001\002\000\074\003\uffce\012\uffce\013" +
    "\uffce\014\uffce\015\uffce\016\uffce\017\uffce\020\uffce\021\uffce" +
    "\022\uffce\023\uffce\024\uffce\025\uffce\031\uffce\032\uffce\035" +
    "\uffce\036\uffce\037\uffce\041\uffce\060\uffce\063\uffce\065\uffce" +
    "\066\uffce\076\uffce\077\uffce\100\uffce\101\uffce\102\uffce\114" +
    "\uffce\001\002\000\074\003\uffc9\012\uffc9\013\uffc9\014\uffc9" +
    "\015\uffc9\016\uffc9\017\uffc9\020\uffc9\021\uffc9\022\uffc9\023" +
    "\uffc9\024\uffc9\025\uffc9\031\uffc9\032\uffc9\035\uffc9\036\uffc9" +
    "\037\uffc9\041\uffc9\060\uffc9\063\uffc9\065\uffc9\066\uffc9\076" +
    "\uffc9\077\uffc9\100\uffc9\101\uffc9\102\uffc9\114\uffc9\001\002" +
    "\000\064\003\uffc4\012\uffc4\014\uffc4\015\uffc4\016\uffc4\017" +
    "\uffc4\022\uffc4\023\uffc4\024\uffc4\025\uffc4\031\uffc4\032\uffc4" +
    "\035\uffc4\036\uffc4\037\uffc4\041\uffc4\060\uffc4\063\uffc4\065" +
    "\uffc4\076\uffc4\077\uffc4\100\uffc4\101\uffc4\102\uffc4\114\uffc4" +
    "\001\002\000\064\003\uffc2\012\uffc2\014\uffc2\015\uffc2\016" +
    "\uffc2\017\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\031\uffc2" +
    "\032\uffc2\035\uffc2\036\uffc2\037\uffc2\041\uffc2\060\uffc2\063" +
    "\uffc2\065\uffc2\076\uffc2\077\uffc2\100\uffc2\101\uffc2\102\uffc2" +
    "\114\uffc2\001\002\000\064\003\063\012\170\014\203\015" +
    "\162\016\207\017\176\022\175\023\161\024\173\025\055" +
    "\031\006\032\020\035\007\036\021\037\012\041\056\060" +
    "\065\063\066\065\200\076\172\077\057\100\053\101\060" +
    "\102\054\114\064\001\002\000\004\014\213\001\002\000" +
    "\004\063\214\001\002\000\030\003\063\025\055\041\056" +
    "\060\065\063\066\076\062\077\057\100\053\101\060\102" +
    "\054\114\064\001\002\000\040\044\072\045\104\046\076" +
    "\047\102\050\101\052\100\053\075\054\073\055\077\056" +
    "\106\057\074\061\070\062\105\064\216\074\071\001\002" +
    "\000\004\072\217\001\002\000\074\003\uffc1\012\uffc1\013" +
    "\uffc1\014\uffc1\015\uffc1\016\uffc1\017\uffc1\020\uffc1\021\uffc1" +
    "\022\uffc1\023\uffc1\024\uffc1\025\uffc1\031\uffc1\032\uffc1\035" +
    "\uffc1\036\uffc1\037\uffc1\041\uffc1\060\uffc1\063\uffc1\065\uffc1" +
    "\066\uffc1\076\uffc1\077\uffc1\100\uffc1\101\uffc1\102\uffc1\114" +
    "\uffc1\001\002\000\004\063\221\001\002\000\030\003\063" +
    "\025\055\041\056\060\065\063\066\076\062\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\040\044\072" +
    "\045\104\046\076\047\102\050\101\052\100\053\075\054" +
    "\073\055\077\056\106\057\074\061\070\062\105\064\223" +
    "\074\071\001\002\000\064\003\uffc3\012\uffc3\014\uffc3\015" +
    "\uffc3\016\uffc3\017\uffc3\022\uffc3\023\uffc3\024\uffc3\025\uffc3" +
    "\031\uffc3\032\uffc3\035\uffc3\036\uffc3\037\uffc3\041\uffc3\060" +
    "\uffc3\063\uffc3\065\uffc3\076\uffc3\077\uffc3\100\uffc3\101\uffc3" +
    "\102\uffc3\114\uffc3\001\002\000\064\003\uffbb\012\uffbb\014" +
    "\uffbb\015\uffbb\016\uffbb\017\uffbb\022\uffbb\023\uffbb\024\uffbb" +
    "\025\uffbb\031\uffbb\032\uffbb\035\uffbb\036\uffbb\037\uffbb\041" +
    "\uffbb\060\uffbb\063\uffbb\065\uffbb\076\uffbb\077\uffbb\100\uffbb" +
    "\101\uffbb\102\uffbb\114\uffbb\001\002\000\064\003\063\012" +
    "\170\014\203\015\162\016\207\017\176\022\175\023\161" +
    "\024\173\025\055\031\006\032\020\035\007\036\021\037" +
    "\012\041\056\060\065\063\066\065\200\076\172\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\074\003" +
    "\uffba\012\uffba\013\uffba\014\uffba\015\uffba\016\uffba\017\uffba" +
    "\020\uffba\021\uffba\022\uffba\023\uffba\024\uffba\025\uffba\031" +
    "\uffba\032\uffba\035\uffba\036\uffba\037\uffba\041\uffba\060\uffba" +
    "\063\uffba\065\uffba\066\uffba\076\uffba\077\uffba\100\uffba\101" +
    "\uffba\102\uffba\114\uffba\001\002\000\074\003\uffad\012\uffad" +
    "\013\uffad\014\uffad\015\uffad\016\uffad\017\uffad\020\uffad\021" +
    "\uffad\022\uffad\023\uffad\024\uffad\025\uffad\031\uffad\032\uffad" +
    "\035\uffad\036\uffad\037\uffad\041\uffad\060\uffad\063\uffad\065" +
    "\uffad\066\uffad\076\uffad\077\uffad\100\uffad\101\uffad\102\uffad" +
    "\114\uffad\001\002\000\066\003\063\012\170\014\203\015" +
    "\162\016\207\017\176\022\175\023\161\024\173\025\055" +
    "\031\006\032\020\035\007\036\021\037\012\041\056\060" +
    "\065\063\066\065\200\066\uffd4\076\172\077\057\100\053" +
    "\101\060\102\054\114\064\001\002\000\004\066\232\001" +
    "\002\000\074\003\uffd0\012\uffd0\013\uffd0\014\uffd0\015\uffd0" +
    "\016\uffd0\017\uffd0\020\uffd0\021\uffd0\022\uffd0\023\uffd0\024" +
    "\uffd0\025\uffd0\031\uffd0\032\uffd0\035\uffd0\036\uffd0\037\uffd0" +
    "\041\uffd0\060\uffd0\063\uffd0\065\uffd0\066\uffd0\076\uffd0\077" +
    "\uffd0\100\uffd0\101\uffd0\102\uffd0\114\uffd0\001\002\000\030" +
    "\002\uffec\003\uffec\004\uffec\011\uffec\031\uffec\032\uffec\035" +
    "\uffec\036\uffec\037\uffec\066\uffec\114\uffec\001\002\000\030" +
    "\003\063\025\055\041\056\060\065\063\066\076\062\077" +
    "\057\100\053\101\060\102\054\114\064\001\002\000\040" +
    "\044\072\045\104\046\076\047\102\050\101\052\100\053" +
    "\075\054\073\055\077\056\106\057\074\061\070\062\105" +
    "\064\236\074\071\001\002\000\004\065\uffc3\001\002\000" +
    "\004\065\uffac\001\002\000\004\065\241\001\002\000\006" +
    "\020\246\021\242\001\002\000\004\073\262\001\002\000" +
    "\010\020\uffa6\021\uffa6\066\uffa6\001\002\000\010\020\246" +
    "\021\242\066\255\001\002\000\010\020\uffa8\021\uffa8\066" +
    "\uffa8\001\002\000\030\003\063\025\055\041\056\060\065" +
    "\063\066\076\062\077\057\100\053\101\060\102\054\114" +
    "\064\001\002\000\040\044\072\045\104\046\076\047\102" +
    "\050\101\052\100\053\075\054\073\055\077\056\106\057" +
    "\074\061\070\062\105\073\250\074\071\001\002\000\072" +
    "\003\uffa5\012\uffa5\014\uffa5\015\uffa5\016\uffa5\017\uffa5\020" +
    "\uffa5\021\uffa5\022\uffa5\023\uffa5\024\uffa5\025\uffa5\031\uffa5" +
    "\032\uffa5\035\uffa5\036\uffa5\037\uffa5\041\uffa5\060\uffa5\063" +
    "\uffa5\065\uffa5\066\uffa5\076\uffa5\077\uffa5\100\uffa5\101\uffa5" +
    "\102\uffa5\114\uffa5\001\002\000\072\003\063\012\170\014" +
    "\203\015\162\016\207\017\176\020\uffd4\021\uffd4\022\175" +
    "\023\161\024\173\025\055\031\006\032\020\035\007\036" +
    "\021\037\012\041\056\060\065\063\066\065\200\066\uffd4" +
    "\076\172\077\057\100\053\101\060\102\054\114\064\001" +
    "\002\000\010\020\uffa4\021\uffa4\066\uffa4\001\002\000\010" +
    "\020\uffa7\021\uffa7\066\uffa7\001\002\000\010\020\uffa9\021" +
    "\uffa9\066\uffa9\001\002\000\004\065\uffab\001\002\000\004" +
    "\065\257\001\002\000\006\020\246\021\242\001\002\000" +
    "\010\020\246\021\242\066\261\001\002\000\074\003\uffaa" +
    "\012\uffaa\013\uffaa\014\uffaa\015\uffaa\016\uffaa\017\uffaa\020" +
    "\uffaa\021\uffaa\022\uffaa\023\uffaa\024\uffaa\025\uffaa\031\uffaa" +
    "\032\uffaa\035\uffaa\036\uffaa\037\uffaa\041\uffaa\060\uffaa\063" +
    "\uffaa\065\uffaa\066\uffaa\076\uffaa\077\uffaa\100\uffaa\101\uffaa" +
    "\102\uffaa\114\uffaa\001\002\000\072\003\uffa3\012\uffa3\014" +
    "\uffa3\015\uffa3\016\uffa3\017\uffa3\020\uffa3\021\uffa3\022\uffa3" +
    "\023\uffa3\024\uffa3\025\uffa3\031\uffa3\032\uffa3\035\uffa3\036" +
    "\uffa3\037\uffa3\041\uffa3\060\uffa3\063\uffa3\065\uffa3\066\uffa3" +
    "\076\uffa3\077\uffa3\100\uffa3\101\uffa3\102\uffa3\114\uffa3\001" +
    "\002\000\072\003\063\012\170\014\203\015\162\016\207" +
    "\017\176\020\uffd4\021\uffd4\022\175\023\161\024\173\025" +
    "\055\031\006\032\020\035\007\036\021\037\012\041\056" +
    "\060\065\063\066\065\200\066\uffd4\076\172\077\057\100" +
    "\053\101\060\102\054\114\064\001\002\000\010\020\uffa2" +
    "\021\uffa2\066\uffa2\001\002\000\074\003\uffc6\012\uffc6\013" +
    "\uffc6\014\uffc6\015\uffc6\016\uffc6\017\uffc6\020\uffc6\021\uffc6" +
    "\022\uffc6\023\uffc6\024\uffc6\025\uffc6\031\uffc6\032\uffc6\035" +
    "\uffc6\036\uffc6\037\uffc6\041\uffc6\060\uffc6\063\uffc6\065\uffc6" +
    "\066\uffc6\076\uffc6\077\uffc6\100\uffc6\101\uffc6\102\uffc6\114" +
    "\uffc6\001\002\000\074\003\uff9f\012\uff9f\013\uff9f\014\uff9f" +
    "\015\uff9f\016\uff9f\017\uff9f\020\uff9f\021\uff9f\022\uff9f\023" +
    "\uff9f\024\uff9f\025\uff9f\031\uff9f\032\uff9f\035\uff9f\036\uff9f" +
    "\037\uff9f\041\uff9f\060\uff9f\063\uff9f\065\uff9f\066\uff9f\076" +
    "\uff9f\077\uff9f\100\uff9f\101\uff9f\102\uff9f\114\uff9f\001\002" +
    "\000\040\044\072\045\104\046\076\047\102\050\101\052" +
    "\100\053\075\054\073\055\077\056\106\057\074\061\070" +
    "\062\105\072\271\074\071\001\002\000\074\003\uffa0\012" +
    "\uffa0\013\uffa0\014\uffa0\015\uffa0\016\uffa0\017\uffa0\020\uffa0" +
    "\021\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0\031\uffa0\032" +
    "\uffa0\035\uffa0\036\uffa0\037\uffa0\041\uffa0\060\uffa0\063\uffa0" +
    "\065\uffa0\066\uffa0\076\uffa0\077\uffa0\100\uffa0\101\uffa0\102" +
    "\uffa0\114\uffa0\001\002\000\074\003\uffa1\012\uffa1\013\uffa1" +
    "\014\uffa1\015\uffa1\016\uffa1\017\uffa1\020\uffa1\021\uffa1\022" +
    "\uffa1\023\uffa1\024\uffa1\025\uffa1\031\uffa1\032\uffa1\035\uffa1" +
    "\036\uffa1\037\uffa1\041\uffa1\060\uffa1\063\uffa1\065\uffa1\066" +
    "\uffa1\076\uffa1\077\uffa1\100\uffa1\101\uffa1\102\uffa1\114\uffa1" +
    "\001\002\000\030\003\063\025\055\041\056\060\065\063" +
    "\066\076\062\077\057\100\053\101\060\102\054\114\064" +
    "\001\002\000\042\044\072\045\104\046\076\047\102\050" +
    "\101\052\100\053\075\054\073\055\077\056\106\057\074" +
    "\061\070\062\105\064\uffae\072\uffae\074\071\001\002\000" +
    "\030\003\063\025\055\041\056\060\065\063\066\076\062" +
    "\077\057\100\053\101\060\102\054\114\064\001\002\000" +
    "\040\044\072\045\104\046\076\047\102\050\101\052\100" +
    "\053\075\054\073\055\077\056\106\057\074\061\070\062" +
    "\105\064\276\074\071\001\002\000\064\003\uffc3\012\uffc3" +
    "\014\uffc3\015\uffc3\016\uffc3\017\uffc3\022\uffc3\023\uffc3\024" +
    "\uffc3\025\uffc3\031\uffc3\032\uffc3\035\uffc3\036\uffc3\037\uffc3" +
    "\041\uffc3\060\uffc3\063\uffc3\065\uffc3\076\uffc3\077\uffc3\100" +
    "\uffc3\101\uffc3\102\uffc3\114\uffc3\001\002\000\064\003\uffc0" +
    "\012\uffc0\014\uffc0\015\uffc0\016\uffc0\017\uffc0\022\uffc0\023" +
    "\uffc0\024\uffc0\025\uffc0\031\uffc0\032\uffc0\035\uffc0\036\uffc0" +
    "\037\uffc0\041\uffc0\060\uffc0\063\uffc0\065\uffc0\076\uffc0\077" +
    "\uffc0\100\uffc0\101\uffc0\102\uffc0\114\uffc0\001\002\000\064" +
    "\003\063\012\170\014\203\015\162\016\207\017\176\022" +
    "\175\023\161\024\173\025\055\031\006\032\020\035\007" +
    "\036\021\037\012\041\056\060\065\063\066\065\200\076" +
    "\172\077\057\100\053\101\060\102\054\114\064\001\002" +
    "\000\064\003\063\012\170\014\203\015\162\016\207\017" +
    "\176\022\175\023\161\024\173\025\055\031\006\032\020" +
    "\035\007\036\021\037\012\041\056\060\065\063\066\065" +
    "\200\076\172\077\057\100\053\101\060\102\054\114\064" +
    "\001\002\000\074\003\uffbf\012\uffbf\013\uffbf\014\uffbf\015" +
    "\uffbf\016\uffbf\017\uffbf\020\uffbf\021\uffbf\022\uffbf\023\uffbf" +
    "\024\uffbf\025\uffbf\031\uffbf\032\uffbf\035\uffbf\036\uffbf\037" +
    "\uffbf\041\uffbf\060\uffbf\063\uffbf\065\uffbf\066\uffbf\076\uffbf" +
    "\077\uffbf\100\uffbf\101\uffbf\102\uffbf\114\uffbf\001\002\000" +
    "\004\013\304\001\002\000\064\003\uffc3\012\uffc3\014\uffc3" +
    "\015\uffc3\016\uffc3\017\uffc3\022\uffc3\023\uffc3\024\uffc3\025" +
    "\uffc3\031\uffc3\032\uffc3\035\uffc3\036\uffc3\037\uffc3\041\uffc3" +
    "\060\uffc3\063\uffc3\065\uffc3\076\uffc3\077\uffc3\100\uffc3\101" +
    "\uffc3\102\uffc3\114\uffc3\001\002\000\064\003\uffbd\012\uffbd" +
    "\014\uffbd\015\uffbd\016\uffbd\017\uffbd\022\uffbd\023\uffbd\024" +
    "\uffbd\025\uffbd\031\uffbd\032\uffbd\035\uffbd\036\uffbd\037\uffbd" +
    "\041\uffbd\060\uffbd\063\uffbd\065\uffbd\076\uffbd\077\uffbd\100" +
    "\uffbd\101\uffbd\102\uffbd\114\uffbd\001\002\000\064\003\063" +
    "\012\170\014\203\015\162\016\207\017\176\022\175\023" +
    "\161\024\173\025\055\031\006\032\020\035\007\036\021" +
    "\037\012\041\056\060\065\063\066\065\200\076\172\077" +
    "\057\100\053\101\060\102\054\114\064\001\002\000\074" +
    "\003\uffbc\012\uffbc\013\uffbc\014\uffbc\015\uffbc\016\uffbc\017" +
    "\uffbc\020\uffbc\021\uffbc\022\uffbc\023\uffbc\024\uffbc\025\uffbc" +
    "\031\uffbc\032\uffbc\035\uffbc\036\uffbc\037\uffbc\041\uffbc\060" +
    "\uffbc\063\uffbc\065\uffbc\066\uffbc\076\uffbc\077\uffbc\100\uffbc" +
    "\101\uffbc\102\uffbc\114\uffbc\001\002\000\072\003\uffd3\012" +
    "\uffd3\014\uffd3\015\uffd3\016\uffd3\017\uffd3\020\uffd3\021\uffd3" +
    "\022\uffd3\023\uffd3\024\uffd3\025\uffd3\031\uffd3\032\uffd3\035" +
    "\uffd3\036\uffd3\037\uffd3\041\uffd3\060\uffd3\063\uffd3\065\uffd3" +
    "\066\uffd3\076\uffd3\077\uffd3\100\uffd3\101\uffd3\102\uffd3\114" +
    "\uffd3\001\002\000\020\031\006\032\020\035\007\036\021" +
    "\037\012\072\uffb3\076\313\001\002\000\004\072\317\001" +
    "\002\000\004\051\272\001\002\000\004\076\050\001\002" +
    "\000\004\072\uffb4\001\002\000\004\072\uffb5\001\002\000" +
    "\032\003\uffc4\025\uffc4\041\uffc4\060\uffc4\063\uffc4\072\uffc4" +
    "\076\uffc4\077\uffc4\100\uffc4\101\uffc4\102\uffc4\114\uffc4\001" +
    "\002\000\032\003\uffb9\025\uffb9\041\uffb9\060\uffb9\063\uffb9" +
    "\072\uffb9\076\uffb9\077\uffb9\100\uffb9\101\uffb9\102\uffb9\114" +
    "\uffb9\001\002\000\032\003\063\025\055\041\056\060\065" +
    "\063\066\072\uffb1\076\062\077\057\100\053\101\060\102" +
    "\054\114\064\001\002\000\004\072\324\001\002\000\040" +
    "\044\072\045\104\046\076\047\102\050\101\052\100\053" +
    "\075\054\073\055\077\056\106\057\074\061\070\062\105" +
    "\072\uffb2\074\071\001\002\000\006\064\uffc3\076\uffc3\001" +
    "\002\000\006\064\uffc3\076\uffc3\001\002\000\006\064\uffc3" +
    "\076\uffc3\001\002\000\006\064\uffb8\076\uffb8\001\002\000" +
    "\006\064\uffaf\076\313\001\002\000\004\064\333\001\002" +
    "\000\004\064\uffb0\001\002\000\064\003\uffb7\012\uffb7\014" +
    "\uffb7\015\uffb7\016\uffb7\017\uffb7\022\uffb7\023\uffb7\024\uffb7" +
    "\025\uffb7\031\uffb7\032\uffb7\035\uffb7\036\uffb7\037\uffb7\041" +
    "\uffb7\060\uffb7\063\uffb7\065\uffb7\076\uffb7\077\uffb7\100\uffb7" +
    "\101\uffb7\102\uffb7\114\uffb7\001\002\000\064\003\063\012" +
    "\170\014\203\015\162\016\207\017\176\022\175\023\161" +
    "\024\173\025\055\031\006\032\020\035\007\036\021\037" +
    "\012\041\056\060\065\063\066\065\200\076\172\077\057" +
    "\100\053\101\060\102\054\114\064\001\002\000\074\003" +
    "\uffb6\012\uffb6\013\uffb6\014\uffb6\015\uffb6\016\uffb6\017\uffb6" +
    "\020\uffb6\021\uffb6\022\uffb6\023\uffb6\024\uffb6\025\uffb6\031" +
    "\uffb6\032\uffb6\035\uffb6\036\uffb6\037\uffb6\041\uffb6\060\uffb6" +
    "\063\uffb6\065\uffb6\066\uffb6\076\uffb6\077\uffb6\100\uffb6\101" +
    "\uffb6\102\uffb6\114\uffb6\001\002\000\074\003\uffc5\012\uffc5" +
    "\013\uffc5\014\uffc5\015\uffc5\016\uffc5\017\uffc5\020\uffc5\021" +
    "\uffc5\022\uffc5\023\uffc5\024\uffc5\025\uffc5\031\uffc5\032\uffc5" +
    "\035\uffc5\036\uffc5\037\uffc5\041\uffc5\060\uffc5\063\uffc5\065" +
    "\uffc5\066\uffc5\076\uffc5\077\uffc5\100\uffc5\101\uffc5\102\uffc5" +
    "\114\uffc5\001\002\000\026\002\ufff8\003\ufff8\004\ufff8\011" +
    "\ufff8\031\ufff8\032\ufff8\035\ufff8\036\ufff8\037\ufff8\114\ufff8" +
    "\001\002\000\026\002\ufff9\003\ufff9\004\ufff9\011\ufff9\031" +
    "\ufff9\032\ufff9\035\ufff9\036\ufff9\037\ufff9\114\ufff9\001\002" +
    "\000\026\002\ufffe\003\ufffe\004\ufffe\011\ufffe\031\ufffe\032" +
    "\ufffe\035\ufffe\036\ufffe\037\ufffe\114\ufffe\001\002\000\004" +
    "\063\uffeb\001\002\000\004\063\344\001\002\000\016\031" +
    "\006\032\020\035\007\036\021\037\012\064\uffe8\001\002" +
    "\000\004\064\346\001\002\000\004\065\347\001\002\000" +
    "\066\003\063\012\170\014\203\015\162\016\207\017\176" +
    "\022\175\023\161\024\173\025\055\031\006\032\020\035" +
    "\007\036\021\037\012\041\056\060\065\063\066\065\200" +
    "\066\uffd4\076\172\077\057\100\053\101\060\102\054\114" +
    "\064\001\002\000\004\066\351\001\002\000\030\002\uffea" +
    "\003\uffea\004\uffea\011\uffea\031\uffea\032\uffea\035\uffea\036" +
    "\uffea\037\uffea\066\uffea\114\uffea\001\002\000\004\002\001" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\350\000\020\002\003\003\013\004\012\005\022\011" +
    "\007\015\016\016\004\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\004\340\005\022\011\007\015\016\016\004\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\017\044" +
    "\020\042\021\043\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\055\026\056\025\001\001\000\016\006\037\007" +
    "\030\010\033\011\031\015\016\016\027\001\001\000\016" +
    "\006\032\007\030\010\033\011\031\015\016\016\027\001" +
    "\001\000\002\001\001\000\012\010\036\011\031\015\016" +
    "\016\027\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\057" +
    "\143\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\021\050\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\052\060\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\052\133\001\001\000\004\052\066\001\001" +
    "\000\002\001\001\000\004\052\132\001\001\000\002\001" +
    "\001\000\004\052\121\001\001\000\004\052\120\001\001" +
    "\000\004\052\117\001\001\000\004\052\116\001\001\000" +
    "\004\052\115\001\001\000\004\052\114\001\001\000\004" +
    "\052\113\001\001\000\004\052\112\001\001\000\004\052" +
    "\111\001\001\000\002\001\001\000\004\052\110\001\001" +
    "\000\004\052\107\001\001\000\004\052\106\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\052\125\053\126\054\124\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\052\131\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\052\125\053\135\054\124\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\052\125\053\141\054\124\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\012\146" +
    "\013\150\014\145\015\147\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\014\152\015\147\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\040\015\156\016\200\022\203" +
    "\023\176\024\165\025\164\026\204\027\170\030\162\031" +
    "\157\033\166\037\205\040\163\043\201\052\173\001\001" +
    "\000\010\017\044\020\042\021\043\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\034\015\156\016" +
    "\200\022\307\025\164\026\204\027\170\030\162\031\157" +
    "\033\166\037\205\040\163\043\201\052\173\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\052\266\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\061\227\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\044\217\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\044\207\001\001\000\004\062" +
    "\210\001\001\000\034\015\156\016\200\022\211\025\164" +
    "\026\204\027\170\030\162\031\157\033\166\037\205\040" +
    "\163\043\201\052\173\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\052\214\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\052\221\001\001\000\002\001\001\000\004\045\223\001" +
    "\001\000\004\066\224\001\001\000\034\015\156\016\200" +
    "\022\225\025\164\026\204\027\170\030\162\031\157\033" +
    "\166\037\205\040\163\043\201\052\173\001\001\000\002" +
    "\001\001\000\002\001\001\000\040\015\156\016\200\022" +
    "\203\023\230\024\165\025\164\026\204\027\170\030\162" +
    "\031\157\033\166\037\205\040\163\043\201\052\173\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\052\234\001\001\000\002\001\001\000\004\045" +
    "\236\001\001\000\004\072\237\001\001\000\002\001\001" +
    "\000\010\034\243\035\244\036\242\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\035\253\036\252\001\001" +
    "\000\002\001\001\000\004\052\246\001\001\000\002\001" +
    "\001\000\004\074\250\001\001\000\040\015\156\016\200" +
    "\022\203\023\251\024\165\025\164\026\204\027\170\030" +
    "\162\031\157\033\166\037\205\040\163\043\201\052\173" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\073\255\001\001\000\002\001\001\000\010" +
    "\034\257\035\244\036\242\001\001\000\006\035\253\036" +
    "\252\001\001\000\002\001\001\000\004\075\262\001\001" +
    "\000\040\015\156\016\200\022\203\023\263\024\165\025" +
    "\164\026\204\027\170\030\162\031\157\033\166\037\205" +
    "\040\163\043\201\052\173\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\052\272\001\001\000" +
    "\002\001\001\000\004\052\274\001\001\000\002\001\001" +
    "\000\004\045\276\001\001\000\006\063\300\064\277\001" +
    "\001\000\034\015\156\016\200\022\302\025\164\026\204" +
    "\027\170\030\162\031\157\033\166\037\205\040\163\043" +
    "\201\052\173\001\001\000\034\015\156\016\200\022\301" +
    "\025\164\026\204\027\170\030\162\031\157\033\166\037" +
    "\205\040\163\043\201\052\173\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\045\304\001\001\000\004\065" +
    "\305\001\001\000\034\015\156\016\200\022\306\025\164" +
    "\026\204\027\170\030\162\031\157\033\166\037\205\040" +
    "\163\043\201\052\173\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\015\313\041\311\043\314\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\017\315\020\042" +
    "\021\043\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\044\317\001\001\000\004\067\320\001\001\000\006" +
    "\032\321\052\322\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\045\324\001\001\000\004\045\325\001\001" +
    "\000\004\045\326\001\001\000\004\070\327\001\001\000" +
    "\006\042\330\043\331\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\071\333\001\001\000\034\015\156\016" +
    "\200\022\334\025\164\026\204\027\170\030\162\031\157" +
    "\033\166\037\205\040\163\043\201\052\173\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\060\342\001\001\000" +
    "\002\001\001\000\012\012\344\013\150\014\145\015\147" +
    "\001\001\000\002\001\001\000\002\001\001\000\040\015" +
    "\156\016\200\022\203\023\347\024\165\025\164\026\204" +
    "\027\170\030\162\031\157\033\166\037\205\040\163\043" +
    "\201\052\173\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Sintactico$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Sintactico$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Sintactico$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
    }


    public ParserHelper helper = new ParserHelper();
    
    public void report_error(String message, Object info) {
        helper.reportSyntaxError(message, (Symbol) info);
    }
    
    public void syntax_error(Symbol cur_token) {
        helper.reportSyntaxError("Token inesperado", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        
        helper.reportSyntaxError("Error sintáctico irrecuperable. Se detendrá el análisis de esta estructura", cur_token);
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Sintactico$actions {
  private final Sintactico parser;

  /** Constructor */
  CUP$Sintactico$actions(Sintactico parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Sintactico$do_action(
    int                        CUP$Sintactico$act_num,
    java_cup.runtime.lr_parser CUP$Sintactico$parser,
    java.util.Stack            CUP$Sintactico$stack,
    int                        CUP$Sintactico$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Sintactico$result;

      /* select the action based on the action number */
      switch (CUP$Sintactico$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // expresion ::= LEXICAL_ERROR 
            {
              ParserHelper.ExprResult RESULT =null;
		
        RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // expresion ::= expresion PUNTO ID PARENTESIS_APERTURA lista_argumentos PARENTESIS_CIERRE 
            {
              ParserHelper.ExprResult RESULT =null;
		int objleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).left;
		int objright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).right;
		ParserHelper.ExprResult obj = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		int memberleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).left;
		int memberright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).right;
		String member = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		java.util.List<ParserHelper.ExprResult> args = (java.util.List<ParserHelper.ExprResult>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		
        if (obj.tipo.equals(ParserHelper.T_ERROR)) {
             RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (!parser.helper.clases.containsKey(obj.tipo)) {
             parser.helper.reportSemanticError("El tipo '" + obj.tipo + "' no es una clase", objleft+1, objright+1);
             RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else {
             ParserHelper.ClassInfo ci = parser.helper.clases.get(obj.tipo);
             if (!ci.miembros.containsKey(member)) {
                  parser.helper.reportSemanticError("Método '" + member + "' no existe en clase '" + obj.tipo + "'", objleft+1, objright+1);
                  RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
             } else {
                  ParserHelper.SymbolInfo info = ci.miembros.get(member);
                  if (!info.esFuncion) {
                      parser.helper.reportSemanticError("'" + member + "' no es un método", objleft+1, objright+1);
                      RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
                  } else {
                      String t = parser.helper.generarTemp();
                      parser.helper.emitir("param " + obj.direccion); // this
                      for(ParserHelper.ExprResult arg : args) {
                          parser.helper.emitir("param " + arg.direccion);
                      }
                      parser.helper.emitir(t + " = call " + obj.direccion + "." + member + ", " + (args.size() + 1));
                      RESULT = new ParserHelper.ExprResult(info.tipo, null, t);
                  }
             }
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // expresion ::= expresion PUNTO ID 
            {
              ParserHelper.ExprResult RESULT =null;
		int objleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int objright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult obj = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int memberleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int memberright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String member = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (obj.tipo.equals(ParserHelper.T_ERROR)) {
             RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (!parser.helper.clases.containsKey(obj.tipo)) {
             parser.helper.reportSemanticError("El tipo '" + obj.tipo + "' no es una clase", objleft+1, objright+1);
             RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else {
             ParserHelper.ClassInfo ci = parser.helper.clases.get(obj.tipo);
             if (!ci.miembros.containsKey(member)) {
                  parser.helper.reportSemanticError("Miembro '" + member + "' no existe en clase '" + obj.tipo + "'", objleft+1, objright+1);
                  RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
             } else {
                  ParserHelper.SymbolInfo info = ci.miembros.get(member);
                  String t = parser.helper.generarTemp();
                  parser.helper.emitir(t + " = " + obj.direccion + "." + member);
                  RESULT = new ParserHelper.ExprResult(info.tipo, null, t);
             }
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // expresion ::= NEW ID PARENTESIS_APERTURA lista_argumentos PARENTESIS_CIERRE 
            {
              ParserHelper.ExprResult RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		java.util.List<ParserHelper.ExprResult> args = (java.util.List<ParserHelper.ExprResult>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		
        if (!parser.helper.clases.containsKey(id_name)) {
             parser.helper.reportSemanticError("Clase '" + id_name + "' no definida", id_nameleft+1, id_nameright+1);
             RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else {
             String t = parser.helper.generarTemp();
             parser.helper.emitir(t + " = new " + id_name);
             RESULT = new ParserHelper.ExprResult(id_name, null, t);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // expresion ::= error 
            {
              ParserHelper.ExprResult RESULT =null;
		
        parser.helper.reportSyntaxError("Expresión mal formada.", null);
        RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null); 
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // expresion ::= expresion MAYOR_IGUAL expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esNumerico(e1.tipo) && parser.helper.esNumerico(e2.tipo)) {
            Object valor = null;
            if (e1.valor != null && e2.valor != null) {
                try {
                    valor = Float.parseFloat(e1.valor.toString()) >= Float.parseFloat(e2.valor.toString());
                } catch (NumberFormatException ex) {
                    // Si hay error al convertir,  valor como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '>=' solo aplicable a tipos numéricos, no a '" + 
                e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // expresion ::= expresion MENOR_IGUAL expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esNumerico(e1.tipo) && parser.helper.esNumerico(e2.tipo)) {
            Object valor = null;
            if (e1.valor != null && e2.valor != null) {
                try {
                    valor = Float.parseFloat(e1.valor.toString()) <= Float.parseFloat(e2.valor.toString());
                } catch (NumberFormatException ex) {
                    // Si hay error al convertir, deja valor como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '<=' solo aplicable a tipos numéricos, no a '" + 
                e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // expresion ::= expresion MAYOR expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esNumerico(e1.tipo) && parser.helper.esNumerico(e2.tipo)) {
            Object valor = null;
            if (e1.valor != null && e2.valor != null) {
                try {
                    valor = Float.parseFloat(e1.valor.toString()) > Float.parseFloat(e2.valor.toString());
                } catch (NumberFormatException ex) {
                    // Si hay error al convertir, dejamos el valor como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '>' solo aplicable a tipos numéricos, no a '" + 
                e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // expresion ::= expresion MENOR expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esNumerico(e1.tipo) && parser.helper.esNumerico(e2.tipo)) {
            Object valor = null;
            if (e1.valor != null && e2.valor != null) {
                try {
                    valor = Float.parseFloat(e1.valor.toString()) < Float.parseFloat(e2.valor.toString());
                } catch (NumberFormatException ex) {
                    // Si hay error al convertir queda como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '<' solo aplicable a tipos numéricos, no a '" + 
                e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // expresion ::= expresion DIFERENCIA expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarComparacion(e1.tipo, e2.tipo, "!=", e1left + 1, e1right + 1);
        Object valor = null;
        if (e1.valor != null && e2.valor != null && tipo.equals(ParserHelper.T_BOOL)) {
            valor = !e1.valor.toString().equals(e2.valor.toString());
        }
        RESULT = new ParserHelper.ExprResult(tipo, valor);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // expresion ::= expresion IGUAL expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarComparacion(e1.tipo, e2.tipo, "==", e1left + 1, e1right + 1);
        Object valor = null;
        if (e1.valor != null && e2.valor != null && tipo.equals(ParserHelper.T_BOOL)) {
            valor = e1.valor.toString().equals(e2.valor.toString());
        }
        RESULT = new ParserHelper.ExprResult(tipo, valor);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // expresion ::= NOT expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esBooleano(e.tipo)) {
            Object valor = null;
            if (e.valor != null) {
                try {
                    valor = !Boolean.parseBoolean(e.valor.toString());
                } catch (Exception ex) {
                    // Si hay error al convertir, dejamos el valor como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '!' solo aplicable a tipo booleano, no a '" + e.tipo + "'",
                eleft + 1, eright + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // expresion ::= expresion OR expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarOperacionLogica(e1.tipo, e2.tipo, "||", e1left + 1, e1right + 1);
        Object valor = null;
        if (e1.valor != null && e2.valor != null && tipo.equals(ParserHelper.T_BOOL)) {
            try {
                valor = Boolean.parseBoolean(e1.valor.toString()) || Boolean.parseBoolean(e2.valor.toString());
            } catch (Exception ex) {
                // Si hay error al convertir, dejamos el valor como null
            }
        }
        RESULT = new ParserHelper.ExprResult(tipo, valor);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // expresion ::= expresion AND expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarOperacionLogica(e1.tipo, e2.tipo, "&&", e1left + 1, e1right + 1);
        Object valor = null;
        if (e1.valor != null && e2.valor != null && tipo.equals(ParserHelper.T_BOOL)) {
            try {
                valor = Boolean.parseBoolean(e1.valor.toString()) && Boolean.parseBoolean(e2.valor.toString());
            } catch (Exception ex) {
                
            }
        }
        RESULT = new ParserHelper.ExprResult(tipo, valor);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // expresion ::= expresion MODULO expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (e1.tipo.equals(ParserHelper.T_INT) && e2.tipo.equals(ParserHelper.T_INT)) {
            Object valor = null;
            if (e1.valor != null && e2.valor != null) {
                try {
                    valor = Integer.parseInt(e1.valor.toString()) % Integer.parseInt(e2.valor.toString());
                } catch (NumberFormatException ex) {
                    // Si hay error al convertir deja valor como null
                }
            }
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_INT, valor);
        } else {
            parser.helper.reportSemanticError(
                "Operador '%' solo aplicable a tipos 'int' y 'int', no a '" + 
                e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // expresion ::= expresion DIVISION expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_ERROR) || e2.tipo.equals(ParserHelper.T_ERROR)) {
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else if (parser.helper.esNumerico(e1.tipo) && parser.helper.esNumerico(e2.tipo)) {
            String temp = parser.helper.generarTemp();
            parser.helper.emitir(temp + " = " + e1.direccion + " / " + e2.direccion);
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_FLOAT, null, temp);
        } else {
            parser.helper.reportSemanticError(
                "Operador '/' no aplicable a tipos '" + e1.tipo + "' y '" + e2.tipo + "'",
                e1left + 1, e1right + 1
            );
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expresion ::= expresion MULTIPLICACION expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarOperacionAritmetica(e1.tipo, e2.tipo, "*", e1left + 1, e1right + 1);
        String temp = parser.helper.generarTemp();
        if (!tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.emitir(temp + " = " + e1.direccion + " * " + e2.direccion);
        }
        RESULT = new ParserHelper.ExprResult(tipo, null, temp);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // expresion ::= expresion RESTA expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        String tipo = parser.helper.validarOperacionAritmetica(e1.tipo, e2.tipo, "-", e1left + 1, e1right + 1);
        String temp = parser.helper.generarTemp();
        if (!tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.emitir(temp + " = " + e1.direccion + " - " + e2.direccion);
        }
        RESULT = new ParserHelper.ExprResult(tipo, null, temp);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // expresion ::= expresion SUMA expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult e1 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e2 = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (e1.tipo.equals(ParserHelper.T_STRING) || e2.tipo.equals(ParserHelper.T_STRING)) {
            if (e1.tipo.equals(ParserHelper.T_STRING) && e2.tipo.equals(ParserHelper.T_STRING)) {
                String temp = parser.helper.generarTemp();
                parser.helper.emitir(temp + " = " + e1.direccion + " + " + e2.direccion); // Concatenación
                RESULT = new ParserHelper.ExprResult(ParserHelper.T_STRING, null, temp);
            } else {
                parser.helper.reportSemanticError(
                    "No se puede concatenar string con tipo '" + 
                    (e1.tipo.equals(ParserHelper.T_STRING) ? e2.tipo : e1.tipo) + "'",
                    e1left + 1, e1right + 1
                );
                RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
            }
        } else {
            String tipo = parser.helper.validarOperacionAritmetica(e1.tipo, e2.tipo, "+", e1left + 1, e1right + 1);
            String temp = parser.helper.generarTemp();
            if (!tipo.equals(ParserHelper.T_ERROR)) {
                parser.helper.emitir(temp + " = " + e1.direccion + " + " + e2.direccion);
            }
            RESULT = new ParserHelper.ExprResult(tipo, null, temp);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // expresion ::= PARENTESIS_APERTURA expresion PARENTESIS_CIERRE 
            {
              ParserHelper.ExprResult RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		 RESULT = e; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // expresion ::= ID 
            {
              ParserHelper.ExprResult RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        String t = parser.helper.tipoDe(id_name);
        if (t == null) {
            parser.helper.reportSemanticError("Identificador '"+id_name+"' no declarado", 
                                            id_nameleft + 1, id_nameright + 1);
            RESULT = new ParserHelper.ExprResult(ParserHelper.T_ERROR, null);
        } else {
            ParserHelper.SymbolInfo info = parser.helper.buscarSimboloInfo(id_name);
            // Usamos el nombre del ID como dirección si es variable
            RESULT = new ParserHelper.ExprResult(t, info.valor, id_name);
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // expresion ::= ID PARENTESIS_APERTURA lista_argumentos PARENTESIS_CIERRE 
            {
              ParserHelper.ExprResult RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		java.util.List<ParserHelper.ExprResult> args = (java.util.List<ParserHelper.ExprResult>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		
        String tipoRetorno = parser.helper.validarLlamadaFuncion(id_name, args, id_nameleft + 1, id_nameright + 1);
        String t = parser.helper.generarTemp();
        for(ParserHelper.ExprResult arg : args) {
             parser.helper.emitir("param " + arg.direccion);
        }
        parser.helper.emitir(t + " = call " + id_name + ", " + args.size());
        RESULT = new ParserHelper.ExprResult(tipoRetorno, null, t);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // expresion ::= BOOLEAN 
            {
              ParserHelper.ExprResult RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		Object val = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = new ParserHelper.ExprResult(ParserHelper.T_BOOL, val); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // expresion ::= LITERAL_CARACTER 
            {
              ParserHelper.ExprResult RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = new ParserHelper.ExprResult(ParserHelper.T_CHAR, val); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // expresion ::= LITERAL_CADENA 
            {
              ParserHelper.ExprResult RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = new ParserHelper.ExprResult(ParserHelper.T_STRING, val); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // expresion ::= DECIMAL 
            {
              ParserHelper.ExprResult RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = new ParserHelper.ExprResult(ParserHelper.T_FLOAT, val); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // expresion ::= ENTERO 
            {
              ParserHelper.ExprResult RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = new ParserHelper.ExprResult(ParserHelper.T_INT, val); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("expresion",40, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // sentencia_expr ::= expresion PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_expr",30, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // sentencia_return ::= RETURN PUNTOYCOMA 
            {
              Object RESULT =null;
		
        if (parser.helper.tipoFuncionActual != null && !ParserHelper.T_VOID.equals(parser.helper.tipoFuncionActual)){
            parser.helper.reportSemanticError(
                "Falta valor de retorno en función de tipo '"+parser.helper.tipoFuncionActual+"'",
                0, 0
            );
        }
        parser.helper.emitir("return");
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_return",22, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // sentencia_return ::= RETURN expresion PUNTOYCOMA 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		
        if (parser.helper.tipoFuncionActual == null){
            parser.helper.reportSemanticError("'return' fuera de una función", 
                                            eleft + 1, eright + 1);
        } else if (ParserHelper.T_VOID.equals(parser.helper.tipoFuncionActual)) {
            parser.helper.reportSemanticError("'return' con valor en función void", 
                                            eleft + 1, eright + 1);
        } else if (!parser.helper.tiposCompatibles(parser.helper.tipoFuncionActual, e.tipo)) {
            parser.helper.reportSemanticError(
                "Tipo de retorno incompatible. Se esperaba '"+parser.helper.tipoFuncionActual+
                "' pero se encontró '"+e.tipo+"'",
                eleft + 1, eright + 1
            );
        }
        parser.helper.emitir("return " + e.direccion);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_return",22, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // caso_default ::= DEFAULT DOS_PUNTOS NT$16 bloque_sentencias 
            {
              Object RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("caso_default",28, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // NT$16 ::= 
            {
              Object RESULT =null;

        String L_default = parser.helper.generarEtiqueta();
        parser.helper.emitir(L_default + ":");
        parser.helper.addCaseInfo(new ParserHelper.CaseInfo(null, L_default, true));
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$16",59, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // caso ::= CASE expresion DOS_PUNTOS NT$15 bloque_sentencias 
            {
              Object RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).right;
		ParserHelper.ExprResult val = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		    
        // Los valores de case deben ser constantes
        if (val.valor == null) {
            parser.helper.reportSemanticError(
                "El valor del 'case' debe ser una constante, no una expresión compleja",
                valleft + 1, valright + 1
            );
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("caso",27, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // NT$15 ::= 
            {
              Object RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		ParserHelper.ExprResult val = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;

        String L_case = parser.helper.generarEtiqueta();
        parser.helper.emitir(L_case + ":");
        // Registrar caso
        parser.helper.addCaseInfo(new ParserHelper.CaseInfo(val.valor, L_case, false));
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$15",58, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // lista_casos ::= caso_default 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_casos",26, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // lista_casos ::= lista_casos caso_default 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_casos",26, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // lista_casos ::= caso 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_casos",26, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // lista_casos ::= lista_casos caso 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_casos",26, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentencia_switch ::= SWITCH PARENTESIS_APERTURA expresion PARENTESIS_CIERRE etiqueta_target NT$13 LLAVE_APERTURA lista_casos LLAVE_CIERRE NT$14 LLAVE_APERTURA lista_casos LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-10)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-10)).right;
		ParserHelper.ExprResult expr = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-10)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).value;
		int casosleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).left;
		int casosright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).right;
		Object casos = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		
        String L_dispatch = parser.helper.peekSwitchLabel(); // Necesitamos guardar L_dispatch tambien
        parser.helper.emitir(L_dispatch + ":");
        java.util.List<ParserHelper.CaseInfo> infos = parser.helper.popSwitchCases();
        boolean hasDefault = false;
        String defaultLabel = null;
        
        for(ParserHelper.CaseInfo c : infos) {
            if (c.esDefault) {
                hasDefault = true;
                defaultLabel = c.label;
            } else {
                parser.helper.emitir("if " + expr.direccion + " == " + c.valor + " goto " + c.label);
            }
        }
        
        if (hasDefault) {
            parser.helper.emitir("goto " + defaultLabel);
        } else {
            parser.helper.emitir("goto " + L_end);
        }
        
        parser.helper.emitir(L_end + ":");
        parser.helper.popBreakTarget();
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_switch",25, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-12)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // NT$14 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		ParserHelper.ExprResult expr = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int casosleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int casosright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		Object casos = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
    
        // 'casos' debe ser una lista de CaseInfo
        // Generamos los saltos
        for(ParserHelper.CaseInfo c : casos) {
             if (c.esDefault) {
                 parser.helper.emitir("goto " + c.label);
             } else {
                 parser.helper.emitir("if " + expr.direccion + " == " + c.valor + " goto " + c.label);
             }
        }
        // Si no hay default y no coincide ninguno, salta al final
        parser.helper.emitir("goto " + L_end);
        
        // Emitimos las etiquetas y cuerpos (ya se emitieron al reducir 'caso', pero necesitamos las etiquetas antes)
        // ESPERA: Al reducir 'caso', el codigo del cuerpo YA se emitio.
        // El problema es que el codigo de los IFs debe ir ANTES de los cuerpos.
        // SOLUCION: Los cuerpos de los cases deben emitirse DESPUES de los IFs de despacho.
        // Pero en bottom-up, 'caso' se reduce antes que 'sentencia_switch'.
        // REVISIÓN ESTRATEGIA:
        // Usar un buffer temporal para los cuerpos de los cases? No, muy complejo.
        // ESTRATEGIA COMUN EN UN PASS:
        // 'switch' es dificil en 1 paso sin backpatching o buffers.
        // SIMPLIFICACION:
        // Asumir que 'lista_casos' NO emite el cuerpo, sino que lo guarda? No, 'bloque_sentencias' emite.
        
        // ESTRATEGIA ALTERNATIVA (Jumps al final):
        // No, el flujo es: evaluar expr -> saltar al case correcto -> ejecutar cuerpo -> break salta al final.
        
        // VAMOS A USAR LA ESTRATEGIA DE "GOTO" INVERSO? No.
        
        // SOLUCION PRACTICA PARA 1-PASS:
        // El 'switch' genera un salto a una etiqueta de "despacho" (L_dispatch).
        // Los 'case' generan:
        //    L_case_i: 
        //    ...cuerpo...
        // Y registran (valor, L_case_i) en una lista en el helper.
        // Al final del switch (en esta regla), generamos L_dispatch: y los IFs.
        
        // IMPLEMENTACION:
        // 1. Antes de entrar a lista_casos, generar L_dispatch y emitir "goto L_dispatch"
        // 2. En cada case, generar etiqueta L_case, emitirla, y guardar (val, L_case) en una lista en helper.
        // 3. Al cerrar switch, emitir L_dispatch: y luego los IFs iterando la lista.
        
        String L_dispatch = parser.helper.generarEtiqueta();
        parser.helper.emitir("goto " + L_dispatch);
        
        // Necesitamos una pila de listas de casos en helper para soportar switches anidados
        parser.helper.pushSwitchCases(); 
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$14",57, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // NT$13 ::= 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult expr = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        // Validar que la expresión sea de tipo compatible (int, char, bool)
        if (!expr.tipo.equals(ParserHelper.T_INT) && 
            !expr.tipo.equals(ParserHelper.T_CHAR) && 
            !expr.tipo.equals(ParserHelper.T_BOOL) &&
            !expr.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError(
                "La expresión del 'switch' debe ser de tipo int, char o bool, no '" + expr.tipo + "'",
                exprleft + 1, exprright + 1
            );
        }
        parser.helper.pushBreakTarget(L_end);
        // Guardamos la expresión del switch para compararla en los cases
        // Usamos una variable temporal global o pasamos info hacia abajo
        // Como CUP es bottom-up, los cases se reducen antes que el switch completo
        // PERO la lista_casos se procesa recursivamente.
        // ESTRATEGIA: 
        // 1. Generar etiqueta de prueba para el primer caso
        // 2. Cada caso genera su propio codigo de prueba y salto al cuerpo
        // 3. Necesitamos pasar la direccion de 'expr' a los casos.
        //    Esto es complicado en CUP puro sin atributos heredados.
        //    ALTERNATIVA: Generar codigo "if expr == val goto L_case"
        //    Para esto, necesitamos que 'lista_casos' devuelva una lista de pares (valor, etiqueta)
        //    y luego generamos los IFs aqui arriba.
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$13",56, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia_asignacion ::= asignacion_expr PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_asignacion",29, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // asignacion_expr ::= ID ASIGNACION expresion 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int exprTleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int exprTright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult exprT = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        String t = parser.helper.tipoDe(id_name);
        if (t == null){
            parser.helper.reportSemanticError("Identificador '"+id_name+"' no declarado", 
                                            id_nameleft + 1, id_nameright + 1);
        } else if (!parser.helper.tiposCompatibles(t, exprT.tipo)){
            parser.helper.reportSemanticError(
                "Tipo incompatible en asignación a '"+id_name+
                "'. Se esperaba '"+t+"' pero se recibió '"+exprT.tipo+"'",
                id_nameleft + 1, id_nameright + 1
            );
        } else {
            ParserHelper.SymbolInfo info = parser.helper.buscarSimboloInfo(id_name);
            if (info != null){
                info.valor = exprT.valor;
                parser.helper.emitir(id_name + " = " + exprT.direccion);
            }
        }
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("asignacion_expr",33, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // for_actualizacion ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_actualizacion",32, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // for_actualizacion ::= asignacion_expr 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_actualizacion",32, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // for_condicion ::= 
            {
              ParserHelper.ExprResult RESULT =null;
		 RESULT = null; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_condicion",24, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // for_condicion ::= expresion 
            {
              ParserHelper.ExprResult RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (!cond.tipo.equals(ParserHelper.T_BOOL) && !cond.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError(
                "La condición del 'for' debe ser de tipo booleano, no '" + cond.tipo + "'",
                condleft + 1, condright + 1
            );
        }
        RESULT = cond;
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_condicion",24, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // for_init ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_init",31, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // for_init ::= asignacion_expr 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_init",31, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // for_init ::= tipo_dato dec_variable_lista 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("for_init",31, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia_for ::= FOR PARENTESIS_APERTURA for_init PUNTOYCOMA etiqueta NT$10 for_condicion PUNTOYCOMA etiqueta_target etiqueta_target etiqueta_target NT$11 for_actualizacion PARENTESIS_CIERRE NT$12 sentencia 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int L_condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-11)).left;
		int L_condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-11)).right;
		String L_cond = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-11)).value;
		int cond_resleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).left;
		int cond_resright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).right;
		ParserHelper.ExprResult cond_res = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).value;
		int L_updateleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).left;
		int L_updateright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).right;
		String L_update = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).value;
		int L_bodyleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int L_bodyright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		String L_body = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		
        parser.helper.emitir("goto " + L_update);
        parser.helper.emitir(L_end + ":");
        parser.helper.popBreakTarget();
        parser.helper.popContinueTarget();
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_for",21, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-15)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // NT$12 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).left;
		int L_condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).right;
		String L_cond = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-9)).value;
		int cond_resleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).left;
		int cond_resright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).right;
		ParserHelper.ExprResult cond_res = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).value;
		int L_updateleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).left;
		int L_updateright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).right;
		String L_update = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		int L_bodyleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int L_bodyright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		String L_body = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;

        parser.helper.emitir("goto " + L_cond);
        parser.helper.emitir(L_body + ":");
        parser.helper.pushBreakTarget(L_end);
        parser.helper.pushContinueTarget(L_update);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$12",55, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // NT$11 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		int L_condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int L_condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		String L_cond = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int cond_resleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int cond_resright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		ParserHelper.ExprResult cond_res = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int L_updateleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int L_updateright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String L_update = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_bodyleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int L_bodyright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String L_body = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        // Si hay condicion y es falsa, salir
        if (cond_res != null) {
             parser.helper.emitir("ifFalse " + cond_res.direccion + " goto " + L_end);
        }
        parser.helper.emitir("goto " + L_body);
        parser.helper.emitir(L_update + ":");
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$11",54, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // NT$10 ::= 
            {
              Object RESULT =null;
		int L_condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_cond = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
 parser.helper.emitir(L_cond + ":"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$10",53, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentencia_while ::= WHILE etiqueta PARENTESIS_APERTURA expresion PARENTESIS_CIERRE etiqueta_target NT$9 sentencia 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int L_startleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int L_startright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		String L_start = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		
        parser.helper.emitir("goto " + L_start);
        parser.helper.emitir(L_end + ":");
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_while",20, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // NT$9 ::= 
            {
              Object RESULT =null;
		int L_startleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int L_startright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		String L_start = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        if (!cond.tipo.equals(ParserHelper.T_BOOL) && !cond.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError("Condición while debe ser bool", condleft+1, condright+1);
        }
        parser.helper.emitir("ifFalse " + cond.direccion + " goto " + L_end);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$9",52, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencia_if ::= IF PARENTESIS_APERTURA expresion PARENTESIS_CIERRE etiqueta_target NT$7 sentencia ELSE etiqueta_target NT$8 sentencia 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).value;
		int L_falseleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int L_falseright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		String L_false = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		 parser.helper.emitir(L_end + ":"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_if",19, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-10)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // NT$8 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int L_falseleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int L_falseright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		String L_false = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int L_endleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_endright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_end = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
 
        parser.helper.emitir("goto " + L_end); 
        parser.helper.emitir(L_false + ":"); 
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$8",51, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // NT$7 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_falseleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_falseright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_false = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        if (!cond.tipo.equals(ParserHelper.T_BOOL) && !cond.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError("Condición if debe ser bool", condleft+1, condright+1);
        }
        parser.helper.emitir("ifFalse " + cond.direccion + " goto " + L_false);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$7",50, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencia_if ::= IF PARENTESIS_APERTURA expresion PARENTESIS_CIERRE etiqueta_target NT$6 sentencia 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		int L_falseleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int L_falseright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String L_false = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		 parser.helper.emitir(L_false + ":"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_if",19, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$6 ::= 
            {
              Object RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int L_falseleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_falseright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_false = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        if (!cond.tipo.equals(ParserHelper.T_BOOL) && !cond.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError("Condición if debe ser bool", condleft+1, condright+1);
        }
        parser.helper.emitir("ifFalse " + cond.direccion + " goto " + L_false);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$6",49, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencia_do_while ::= DO etiqueta NT$5 sentencia WHILE PARENTESIS_APERTURA expresion PARENTESIS_CIERRE PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int L_startleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).left;
		int L_startright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).right;
		String L_start = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		ParserHelper.ExprResult cond = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		
        if (!cond.tipo.equals(ParserHelper.T_BOOL) && !cond.tipo.equals(ParserHelper.T_ERROR)) {
            parser.helper.reportSemanticError("Condición do-while debe ser bool", condleft+1, condright+1);
        }
        parser.helper.emitir("if " + cond.direccion + " goto " + L_start);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia_do_while",23, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // NT$5 ::= 
            {
              Object RESULT =null;
		int L_startleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int L_startright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String L_start = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
 parser.helper.emitir(L_start + ":"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$5",48, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // etiqueta_target ::= 
            {
              String RESULT =null;
		 RESULT = parser.helper.generarEtiqueta(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("etiqueta_target",35, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // etiqueta ::= 
            {
              String RESULT =null;
		 RESULT = parser.helper.generarEtiqueta(); parser.helper.emitir(RESULT + ":"); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("etiqueta",34, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencia ::= CONTINUE PUNTOYCOMA 
            {
              Object RESULT =null;
		
          String target = parser.helper.getContinueTarget();
          if (target != null) {
              parser.helper.emitir("goto " + target);
          } else {
              parser.helper.reportSemanticError("Continue fuera de ciclo", 0, 0);
          }
      
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sentencia ::= BREAK PUNTOYCOMA 
            {
              Object RESULT =null;
		
          String target = parser.helper.getBreakTarget();
          if (target != null) {
              parser.helper.emitir("goto " + target);
          } else {
              parser.helper.reportSemanticError("Break fuera de ciclo o switch", 0, 0);
          }
      
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sentencia ::= dec_variable 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencia ::= sentencia_expr 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // sentencia ::= sentencia_asignacion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencia ::= sentencia_return 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // sentencia ::= sentencia_switch 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // sentencia ::= sentencia_do_while 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // sentencia ::= sentencia_for 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // sentencia ::= sentencia_while 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // sentencia ::= sentencia_if 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // sentencia ::= LLAVE_APERTURA NT$4 bloque_sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		 parser.helper.finalizarAmbito(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("sentencia",16, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // NT$4 ::= 
            {
              Object RESULT =null;
 parser.helper.iniciarAmbito(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$4",47, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // lista_sentencias ::= sentencia 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_sentencias",18, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // lista_sentencias ::= lista_sentencias sentencia 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_sentencias",18, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // bloque_sentencias ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",17, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // bloque_sentencias ::= lista_sentencias 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",17, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // id_con_asignacion_opcional ::= ID ASIGNACION expresion 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        if (!parser.helper.tiposCompatibles(parser.helper.tipoActualDecl, e.tipo)) {
            parser.helper.reportSemanticError(
                "Tipo incompatible en inicialización de '" + id_name + 
                "'. Se esperaba '" + parser.helper.tipoActualDecl + "' pero se recibió '" + e.tipo + "'",
                id_nameleft + 1, id_nameright + 1
            );
        }
        parser.helper.insertarSimbolo(id_name, parser.helper.tipoActualDecl, id_nameleft + 1, id_nameright + 1, e.valor);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("id_con_asignacion_opcional",15, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // id_con_asignacion_opcional ::= ID 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 parser.helper.insertarSimbolo(id_name, parser.helper.tipoActualDecl, id_nameleft + 1, id_nameright + 1, null); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("id_con_asignacion_opcional",15, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // lista_ids_con_asignacion ::= id_con_asignacion_opcional 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_ids_con_asignacion",14, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // lista_ids_con_asignacion ::= lista_ids_con_asignacion COMA id_con_asignacion_opcional 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_ids_con_asignacion",14, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // dec_variable_lista ::= lista_ids_con_asignacion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_variable_lista",13, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // dec_variable ::= tipo_dato dec_variable_lista PUNTOYCOMA 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_variable",12, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // tipo_dato ::= BOOL 
            {
              String RESULT =null;
		 parser.helper.tipoActualDecl=ParserHelper.T_BOOL;   RESULT=ParserHelper.T_BOOL;   
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tipo_dato ::= STRING 
            {
              String RESULT =null;
		 parser.helper.tipoActualDecl=ParserHelper.T_STRING; RESULT=ParserHelper.T_STRING; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // tipo_dato ::= CHAR 
            {
              String RESULT =null;
		 parser.helper.tipoActualDecl=ParserHelper.T_CHAR;   RESULT=ParserHelper.T_CHAR;   
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // tipo_dato ::= FLOAT 
            {
              String RESULT =null;
		 parser.helper.tipoActualDecl=ParserHelper.T_FLOAT;  RESULT=ParserHelper.T_FLOAT;  
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // tipo_dato ::= INT 
            {
              String RESULT =null;
		 parser.helper.tipoActualDecl=ParserHelper.T_INT;    RESULT=ParserHelper.T_INT;    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("tipo_dato",11, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // lista_argumentos_no_vacia ::= lista_argumentos_no_vacia COMA expresion 
            {
              java.util.List<ParserHelper.ExprResult> RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		java.util.List<ParserHelper.ExprResult> args = (java.util.List<ParserHelper.ExprResult>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        args.add(e); 
        RESULT = args; 
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_argumentos_no_vacia",42, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // lista_argumentos_no_vacia ::= expresion 
            {
              java.util.List<ParserHelper.ExprResult> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		ParserHelper.ExprResult e = (ParserHelper.ExprResult)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 
        RESULT = new java.util.ArrayList<>();
        RESULT.add(e); 
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_argumentos_no_vacia",42, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // lista_argumentos ::= lista_argumentos_no_vacia 
            {
              java.util.List<ParserHelper.ExprResult> RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		java.util.List<ParserHelper.ExprResult> args = (java.util.List<ParserHelper.ExprResult>)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		 RESULT = args; 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_argumentos",41, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // lista_argumentos ::= 
            {
              java.util.List<ParserHelper.ExprResult> RESULT =null;
		 RESULT = new java.util.ArrayList<>(); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_argumentos",41, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // parametro ::= tipo_dato ID 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;
		
        // Inserta el parametro en el ámbito local de la función
        parser.helper.insertarSimbolo(id_name, t, id_nameleft + 1, id_nameright + 1, null);
        
        // Busca la función actual y agrega el parámetro
        String funcName = parser.helper.alcanceActual.substring("local_".length());
        ParserHelper.SymbolInfo func = parser.helper.buscarSimboloInfo(funcName);
        if (func != null) {
            func.agregarParametro(id_name, t);
        }
        
        RESULT = new ParserHelper.SymbolInfo(t, parser.helper.alcanceActual, id_nameleft + 1, id_nameright + 1, null);
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("parametro",10, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_parametros ::= parametro 
            {
              Object RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_parametros",9, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_parametros ::= lista_parametros COMA parametro 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_parametros",9, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_parametros_opcional ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_parametros_opcional",8, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // lista_parametros_opcional ::= lista_parametros 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_parametros_opcional",8, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // dec_funcion ::= VOID ID NT$3 PARENTESIS_APERTURA lista_parametros_opcional PARENTESIS_CIERRE LLAVE_APERTURA bloque_sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		
        parser.helper.emitir("endFunc");
        parser.helper.finalizarAmbito();
        parser.helper.alcanceActual = "global";
        parser.helper.tipoFuncionActual = null;
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_funcion",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NT$3 ::= 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        // Registramos la función antes de procesar los parámetros
        RESULT = parser.helper.registrarFuncion(id_name, ParserHelper.T_VOID, id_nameleft + 1, id_nameright + 1);
        parser.helper.alcanceActual = "local_" + id_name;
        parser.helper.tipoFuncionActual = ParserHelper.T_VOID;
        parser.helper.iniciarAmbito();
        parser.helper.emitir("func " + id_name + ":");
        parser.helper.emitir("beginFunc");
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$3",46, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // dec_funcion ::= tipo_dato ID NT$2 PARENTESIS_APERTURA lista_parametros_opcional PARENTESIS_CIERRE LLAVE_APERTURA bloque_sentencias LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-7)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		
        parser.helper.emitir("endFunc");
        parser.helper.finalizarAmbito();
        parser.helper.alcanceActual = "global";
        parser.helper.tipoFuncionActual = null;
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_funcion",7, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-8)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$2 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.peek()).value;

        // Registramos la función antes de procesar los parámetros
        RESULT = parser.helper.registrarFuncion(id_name, t, id_nameleft + 1, id_nameright + 1);
        parser.helper.alcanceActual = "local_" + id_name;
        parser.helper.tipoFuncionActual = t;
        parser.helper.iniciarAmbito();
        parser.helper.emitir("func " + id_name + ":");
        parser.helper.emitir("beginFunc");
    
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$2",45, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // miembro ::= dec_variable 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("miembro",6, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // miembro ::= dec_funcion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("miembro",6, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // lista_miembros ::= miembro 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_miembros",5, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // lista_miembros ::= lista_miembros miembro 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_miembros",5, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // cuerpo_clase ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("cuerpo_clase",4, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // cuerpo_clase ::= lista_miembros 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("cuerpo_clase",4, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // dec_clase ::= CLASS ID LLAVE_APERTURA NT$1 cuerpo_clase LLAVE_CIERRE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-2)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-4)).value;
		 
                parser.helper.salirClase(); 
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_clase",3, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // NT$1 ::= 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
 
                parser.helper.registrarClase(id_name); 
                parser.helper.entrarClase(id_name);
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$1",44, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // dec_clase ::= CLASS ID LLAVE_APERTURA NT$0 cuerpo_clase LLAVE_CIERRE PUNTOYCOMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-3)).value;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-5)).value;
		 
                parser.helper.salirClase(); 
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("dec_clase",3, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-6)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$0 ::= 
            {
              Object RESULT =null;
		int id_nameleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int id_nameright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		String id_name = (String)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
 
                parser.helper.registrarClase(id_name); 
                parser.helper.entrarClase(id_name);
            
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("NT$0",43, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declaracion ::= LEXICAL_ERROR PUNTOYCOMA 
            {
              Object RESULT =null;
		 /* El error léxico ya fue reportado por el lexer. Solo nos recuperamos. */ 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declaracion ::= error PUNTOYCOMA 
            {
              Object RESULT =null;
		 parser.helper.reportSyntaxError("Error sintáctico en declaración. Saltando hasta ';'.", null); 
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declaracion ::= dec_variable 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declaracion ::= dec_funcion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaracion ::= dec_clase 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // lista_declaraciones ::= declaracion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_declaraciones",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // lista_declaraciones ::= lista_declaraciones declaracion 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("lista_declaraciones",1, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // programa ::= 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // programa ::= lista_declaraciones 
            {
              Object RESULT =null;

              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("programa",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          return CUP$Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= programa EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)).value;
		RESULT = start_val;
              CUP$Sintactico$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Sintactico$stack.elementAt(CUP$Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Sintactico$parser.done_parsing();
          return CUP$Sintactico$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

